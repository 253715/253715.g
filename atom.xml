<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>学技术的小凯</title>
  
  
  <link href="https://github.com/253715/253715.github.io.git/atom.xml" rel="self"/>
  
  <link href="https://github.com/253715/253715.github.io.git/"/>
  <updated>2022-04-30T12:46:29.672Z</updated>
  <id>https://github.com/253715/253715.github.io.git/</id>
  
  <author>
    <name>JonQuet</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>“hexo备份”</title>
    <link href="https://github.com/253715/253715.github.io.git/2022/04/30/%E2%80%9Chexo%E5%A4%87%E4%BB%BD%E2%80%9D/"/>
    <id>https://github.com/253715/253715.github.io.git/2022/04/30/%E2%80%9Chexo%E5%A4%87%E4%BB%BD%E2%80%9D/</id>
    <published>2022-04-30T12:12:40.000Z</published>
    <updated>2022-04-30T12:46:29.672Z</updated>
    
    <content type="html"><![CDATA[<h2 id="hexo备份"><a href="#hexo备份" class="headerlink" title="hexo备份"></a>hexo备份</h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    使用Hexo在github搭建的博客，博客作为一个单独的GitHub仓库存在，但是这个仓库只有生成的静态网页文件，并没有Hexo的源文件，如果要换电脑或者重装系统后，就比较麻烦了，这里推荐一种方法。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>我们的博客是托管到 GitHub（Coding） 上的。而我们每次上传（<code>hexo d</code>）的是网页文件，不是我们的文章，所以我们如果想上传文章，但同时不会干扰到网页部署，就在 GitHub 的博客仓库上建立一个分支 hexo。</p><p>这个 hexo 分支的作用就是用来保存我的博客所有文件。所以第一步我们就获得了博客仓库的 .git 文件夹，作用就是利用它连接到我们的博客仓库，而且建立分支 hexo。所以拿到这个文件夹，我们就把除了它的其他文件删掉。</p><p>然后利用这个分支，把我们的 MarkDown 文章和其他文件上传到 GitHub 托管。这样 <code>hexo d</code>推送的是 master 分支，而 <code>git push</code> 推送的是 hexo 分支，互不干扰。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="1-获取-git文件"><a href="#1-获取-git文件" class="headerlink" title="1. 获取.git文件"></a>1. 获取.git文件</h3><ol><li><p>我们先建立一个文件夹，名字随便，我这里叫 hexo，在该文件夹空白处，启动 GitBash</p></li><li><p>先克隆我们博客的仓库</p><pre class="line-numbers language-none"><code class="language-none">git clone https://e.coding.net/fenghen0918/fenghen0918.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p>这里仅仅只是为了获得版本管理的 <strong>.git</strong> 隐藏文件夹。</p><h3 id="2-建立分支"><a href="#2-建立分支" class="headerlink" title="2. 建立分支"></a>2. 建立分支</h3><p>建立一个分支，我这里分支名为 hexo ，输入代码</p><pre class="line-numbers language-none"><code class="language-none">git checkout -b hexo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-清空-hexo-分支"><a href="#3-清空-hexo-分支" class="headerlink" title="3. 清空 hexo 分支"></a>3. 清空 hexo 分支</h3><p>克隆下来的都是编译后的静态页面，直接删除留下.git即可。</p><ol><li>删除除了 .git 文件夹的所有文件。我们只需要这个版本管理，在删除后通过代码 <code>git status</code> 查看</li></ol><p><img src="https://gitee.com/rising-silently/git/raw/master/img/20220430201741.png" alt="img"></p><ol><li><p>增加到暂存区</p><pre class="line-numbers language-none"><code class="language-none">git add --all<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>提交到本地仓库</p><pre class="line-numbers language-none"><code class="language-none">git commit -m  "清空hexo分支仓库"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>最后我们推送到远端更新</p><pre class="line-numbers language-none"><code class="language-none">git push --set-upstream origin hexo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p>这里同时设置了以后默认为hexo分支，回到博客的根目录下就能看到。</p><p><img src="https://gitee.com/rising-silently/git/raw/master/img/20220430202000.png" alt="image-20220430202000179"></p><blockquote><p>注意：这时默认分支为hexo，但博客部署的还是master分支，此配置在config.yml中配置的</p><pre class="line-numbers language-none"><code class="language-none">deploy:  type: git  repo: https://github.com/Witman1999/Witman1999.github.io.git  branch: master #提交的默认分支<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h3 id="4-移动-git文件"><a href="#4-移动-git文件" class="headerlink" title="4. 移动.git文件"></a>4. 移动.git文件</h3><p>把 .git 文件夹移动到博客的根目录下</p><h3 id="5-提交源文件"><a href="#5-提交源文件" class="headerlink" title="5. 提交源文件"></a>5. 提交源文件</h3><blockquote><p>注意：如果你的主题文件，是克隆 Github 下来的，那么会带有该主题的 Github 的 .git 版本管理文件，也就是 .git 文件夹。所以主题下面的要删除 .git 文件夹和 .gitignore 文件，否则会忽略这个 next 主题的上传。</p></blockquote><p>推送 Github 的仓库的步骤，在博客的根目录下，输入</p><pre class="line-numbers language-none"><code class="language-none">git add --allgit commit -m “提交源文件”git push （这里要确保提交的分支为 hexo ，在前面的步骤可以查看，如果不是可以输入 git checkout hexo切换分支）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>此时会发现在远程仓库的Hexo分支中已经推送了绝大部分文件，只有一些被忽略的文件，这些被忽略的并不需要拷贝</p><ol><li><code>_config.yml</code>站点的配置文件，需要拷贝；</li><li><code>themes/</code>主题文件夹，需要拷贝；</li><li><code>source</code>博客文章的.md文件，需要拷贝；</li><li><code>scaffolds/</code>文章的模板，需要拷贝；</li><li><code>package.json</code>安装包的名称，需要拷贝；</li><li><code>.gitignore</code>限定在push时哪些文件可以忽略，需要拷贝；</li><li><code>.git/</code>主题和站点都有，标志这是一个git项目，不需要拷贝；</li><li><code>node_modules/</code>是安装包的目录，在执行<code>npm install</code>的时候会重新生成，不需要拷贝；</li><li><code>public</code>是<code>hexo g</code>生成的静态网页，不需要拷贝；</li><li><code>.deploy_git</code>同上，<code>hexo g</code>也会生成，不需要拷贝；</li><li><code>db.json</code>文件，不需要拷贝。</li></ol><p>其实不需要拷贝的文件正是<code>.gitignore</code>中所忽略的。</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>在本地对博客修改（包括修改主题样式、发布新文章等）后：</p><ol><li>依次执行<code>git add .</code>、<code>git commit -m "推送"</code>、<code>git push origin hexo</code>来提交hexo网站源文件，因为我设置了默认hexo分支，直接输入<code>git push</code>即可；</li><li>执行<code>hexo g -d</code>生成静态网页部署至Github上，我使用了gulp插件压缩代码，所以直接输入<code>gulp</code>，<code>hexo d</code>即可。</li></ol><h2 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h2><h3 id="1-配置Hexo环境"><a href="#1-配置Hexo环境" class="headerlink" title="1.配置Hexo环境"></a>1.配置Hexo环境</h3><p>重装电脑后，或者在其它电脑上想修改博客：</p><ol><li>安装git；</li><li>安装Nodejs和npm；</li><li>使用<code>git clone git@github.com:WincerChan/WincerChan.github.io.git</code>将仓库拷贝至本地；</li><li>在文件夹内执行以下命令<code>npm install hexo-cli -g</code>、<code>npm install</code>、<code>npm install hexo-deployer-git</code>。</li></ol><h3 id="2-添加ssh-keys"><a href="#2-添加ssh-keys" class="headerlink" title="2.添加ssh-keys"></a>2.添加ssh-keys</h3><ol><li>在终端下运行：<code>ssh-keygen -t rsa -C "yourname@email.com"</code>，一路回车；</li><li>会在.ssh目录生成<code>id_rsa</code>、<code>id_rsa.pub</code>两个文件，这就是密钥对，id_rsa是私钥，千万不能泄漏出去；</li><li>登录Github，打开「Settings」–&gt;「SSH and GPG keys」，然后点击「new SSH key」，填上任意Title，在Key文本框里粘贴公钥id_rsa.pub文件的内容，注意不要粘贴成<code>id_rsa</code>，最后点击「Add SSH Key」。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;hexo备份&quot;&gt;&lt;a href=&quot;#hexo备份&quot; class=&quot;headerlink&quot; title=&quot;hexo备份&quot;&gt;&lt;/a&gt;hexo备份&lt;/h2&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="博客" scheme="https://github.com/253715/253715.github.io.git/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="hexo" scheme="https://github.com/253715/253715.github.io.git/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>spingboot</title>
    <link href="https://github.com/253715/253715.github.io.git/2022/04/30/Verio%E8%A7%86%E9%A2%91%E8%AE%B2%E8%A7%A3%E8%AF%B4%E6%98%8E/"/>
    <id>https://github.com/253715/253715.github.io.git/2022/04/30/Verio%E8%A7%86%E9%A2%91%E8%AE%B2%E8%A7%A3%E8%AF%B4%E6%98%8E/</id>
    <published>2022-04-30T06:32:41.000Z</published>
    <updated>2022-04-30T12:16:51.431Z</updated>
    
    <content type="html"><![CDATA[<p>Verio是一个基于SSM+JSP的房屋租赁系统，包括管理员、房东和租客三种角色。<br>介绍地址：</p><h2 id="0-视频介绍"><a href="#0-视频介绍" class="headerlink" title="0. 视频介绍"></a>0. 视频介绍</h2><h2 id="1-项目导入，推荐插件安装，启动项目"><a href="#1-项目导入，推荐插件安装，启动项目" class="headerlink" title="1. 项目导入，推荐插件安装，启动项目"></a>1. 项目导入，推荐插件安装，启动项目</h2><h4 id="1）项目导入过程如下"><a href="#1）项目导入过程如下" class="headerlink" title="1）项目导入过程如下"></a>1）项目导入过程如下</h4><ul><li>通过IDEA导入，修改Constant里uploads目录位置</li><li>修改 db.properties</li><li>配置tomcat</li><li>创建数据库</li><li>导入数据库</li><li>运行tomcat</li></ul><h4 id="2）推荐插件"><a href="#2）推荐插件" class="headerlink" title="2）推荐插件"></a>2）推荐插件</h4><ul><li>搜索 Lombok，功能是帮我们生成getter/setter方法，在类上面加@Data注解即可，不要再写一大堆getter/setter方法啦！</li><li>搜索 Free MyBatis，功能是帮我们从mapper接口快速跳转到mapper xml </li><li>搜索 RestfulToolkit，帮我们快速找到接口代码位置，即根据接口路径找controller类里方法位置，快捷键 ctrl + \</li></ul><h2 id="2-数据库设计讲解和功能介绍，交叉讲"><a href="#2-数据库设计讲解和功能介绍，交叉讲" class="headerlink" title="2. 数据库设计讲解和功能介绍，交叉讲"></a>2. 数据库设计讲解和功能介绍，交叉讲</h2><ul><li>t_feedback  反馈表</li><li>t_house  房屋信息表</li><li>t_mark  收藏表</li><li>t_news  新闻表</li><li>t_order     订单表</li><li>t_user   用户表</li></ul><h2 id="3-代码结构简单说明"><a href="#3-代码结构简单说明" class="headerlink" title="3. 代码结构简单说明"></a>3. 代码结构简单说明</h2><ul><li><p>pom.xml 项目依赖工具</p></li><li><p>src/main 代码父目录</p></li><li><pre><code>java  Java代码目录</code></pre></li><li><pre><code>    common 公共的类：配置、常量、封装的对象 </code></pre></li><li><pre><code>    controller  控制器，负责接收请求，后端代码入口在这里，通常这一层会去调用 service 层(本质是service impl层)</code></pre></li><li><pre><code>    entity实体类，跟数据库表一一对应，表名对应类名，字段名对应属性名</code></pre></li><li><pre><code>    mapper数据访问层，即直接操作数据库的接口(继承baseMapper，省去了增删改查的方法)</code></pre></li><li><pre><code>    service业务逻辑层接口</code></pre></li><li><pre><code>        impl业务逻辑层实现，通常这一层会去调用 mapper 层</code></pre></li><li><p>常用调用关系：</p><pre class="line-numbers language-none"><code class="language-none">浏览器或js里的ajax方法 -&gt; controller -&gt; service impl -&gt; mapper -&gt;数据库SQL语句<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>java  Java代码目录</p></li><li><p>resources 配置文件目录</p></li><li><p>webapp 前端文件目录</p></li></ul><h2 id="4-Spring讲解"><a href="#4-Spring讲解" class="headerlink" title="4. Spring讲解"></a>4. Spring讲解</h2><p>Spring帮我们管理对象，不会重复创建对象，节约内存</p><h4 id="1-使用方法"><a href="#1-使用方法" class="headerlink" title="1. 使用方法"></a>1. 使用方法</h4><ul><li>1）给需要让Spring管理的类加注解，如 @Service、@Controller、@Repository、@Component，如<pre class="line-numbers language-none"><code class="language-none">@Servicepublic class HouseServiceImpl implements HouseService {......}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li>2）给需要创建对象的地方，@Autowired，如<pre class="line-numbers language-none"><code class="language-none">@Autowiredprivate HouseService houseService;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h2 id="5-MyBatis讲解，JDBC、MyBatis、MyBatisPlus对比"><a href="#5-MyBatis讲解，JDBC、MyBatis、MyBatisPlus对比" class="headerlink" title="5. MyBatis讲解，JDBC、MyBatis、MyBatisPlus对比"></a>5. MyBatis讲解，JDBC、MyBatis、MyBatisPlus对比</h2><p>mybatis：替代原始的JDBC的方法，直接通过定义接口，一个方法对应一个SQL语句，mybatis帮我们执行，不需要我们去处理像JDBC一样拿数据那么麻烦</p><p>举例：根据用户ID查询用户</p><ul><li><p>1）JDBC的写法</p><pre class="line-numbers language-none"><code class="language-none">String sql = "SELECT * FROM user where id= ? ";PreparedStatement statement = connection.prepareStatement(sql);statement.setString(1, name);ResultSet rs = statement.executeQuery();while (rs.next()) {// 将数据库的数据转换成POJO实例user.setId(rs.getInt("id"));user.setUserName(rs.getString("userName"));user.setNickName(rs.getString("nickname"));user.setPhone(rs.getString("phone"));user.setEmail(rs.getString("email"));...... // 有几个属性需要set几次}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>2）MyBatis 写法</p><pre class="line-numbers language-none"><code class="language-none">@Select("select * from user where id = #{value}")User findById(Long id);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>3） MyBatis Plus写法<br>直接让Mapper接口基础 BaseMapper ，不需要再去写增删改查的逻辑了，直接从父类里面调用，父类的实现由mybatis plus帮我们做(动态代理实现)</p></li></ul><h2 id="6-SpringMVC讲解，Servlet和SpringMVC对比"><a href="#6-SpringMVC讲解，Servlet和SpringMVC对比" class="headerlink" title="6. SpringMVC讲解，Servlet和SpringMVC对比"></a>6. SpringMVC讲解，Servlet和SpringMVC对比</h2><p>SpringMVC 帮助我们管理请求接口，处理请求<br>如 查询用户信息页面</p><h4 id="Servlet-和-SpringMVC对比"><a href="#Servlet-和-SpringMVC对比" class="headerlink" title="Servlet 和 SpringMVC对比"></a>Servlet 和 SpringMVC对比</h4><ul><li><p>1）Servlet 的写法</p><pre class="line-numbers language-none"><code class="language-none">@WebServlet("/user/info")public class UserInfoGetServlet extends HttpServlet {    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        // 解决乱码        request.setCharacterEncoding("utf-8");        // 获取用户ID        Long id = (Long) request.getParameter("id");       // 去调用service 查询用户信息       User user = userService.findById(id);        // 把用户信息传给前端         request.setAttribute("user", user);        //向页面跳转        request.getRequestDispatcher("/jsp/user/info.jsp").forward(request,response);    }    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        this.doGet(req, resp);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><ol start="2"><li>SpringMVC写法<pre class="line-numbers language-none"><code class="language-none">@RequestMapping("/user/info")public String profile(@RequestParam("id") Long id,  Model model) {// 去调用service 查询用户信息    User user = userService.get(id);    // 把用户信息传给前端     model.addAttribute("user", user);    // 页面跳转,在这个页面渲染    return "admin/my-profile";}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol></li></ul><h4 id="SpringMVC详细讲解"><a href="#SpringMVC详细讲解" class="headerlink" title="SpringMVC详细讲解"></a>SpringMVC详细讲解</h4><p>1）@RequestParam<br>如新闻列表</p><pre class="line-numbers language-none"><code class="language-none">@RequestMapping("/news")   public String index(@RequestParam(value = "page", defaultValue = "1") Integer pageNumber,                       @RequestParam(value = "size", defaultValue = "6") Integer pageSize,) {       ...   }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2）@PathVariable<br>房子详情页面</p><pre class="line-numbers language-none"><code class="language-none">@RequestMapping("/house/detail/{id}")   public String search(@PathVariable("id") Long id) {   ...   }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>@ResponseBody<br>登录提交请求<pre class="line-numbers language-none"><code class="language-none">@RequestMapping(value = "/login/submit", method = RequestMethod.POST)   @ResponseBody   public JsonResult loginSubmit(@RequestParam("userName") String userName,                                 @RequestParam("userPass") String userPass) {}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="7-JSP讲解"><a href="#7-JSP讲解" class="headerlink" title="7.JSP讲解"></a>7.JSP讲解</h2><p>模块分块，c:if、c:forEach 等标签的使用，${xxx} 的使用，时间格式化的使用</p><h2 id="8-JavaScript-和-ajax"><a href="#8-JavaScript-和-ajax" class="headerlink" title="8.JavaScript 和 ajax"></a>8.JavaScript 和 ajax</h2><p>onclick=””<br>登录代码示例</p><p>代码位置/webapp/assets/js/script.js<br>JS代码</p><pre class="line-numbers language-none"><code class="language-none">function submitLogin() {    $.ajax({        type: 'POST',        url: '/login/submit',        async: false,        data: $("#loginForm").serialize(), // 获取该表单下的所有参数        success: function (data) {            // 提示信息            alert(data.msg);            // 如果登录成功，刷新页面            if (data.code == 1) {                window.location.reload();            }        }    });}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>JSP的代码</p><pre class="line-numbers language-none"><code class="language-none">&lt;button type="button" onclick="submitLogin()" class="btn btn-md full-width pop-login bg-2"&gt;登录&lt;/button&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>后端 <code>/login/submit</code> 这个请求的，可以通过 ctrl + \ 搜索，找到<br>后端代码controller这个方法必须要加 @ResponseBody</p><h2 id="9-怎么找代码和看代码？"><a href="#9-怎么找代码和看代码？" class="headerlink" title="9. 怎么找代码和看代码？"></a>9. 怎么找代码和看代码？</h2><ul><li>全局搜索字符串，快捷键 ctrl + shift + f，比如我想搜索这个项目里所有的 Verio 的字符串，可以用这个快捷键</li><li>搜索接口，ctrl + \ ，比如我想搜索用户相关的接口，搜 /user，比如我要搜登录接口代码 /login/submit</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Verio是一个基于SSM+JSP的房屋租赁系统，包括管理员、房东和租客三种角色。&lt;br&gt;介绍地址：&lt;/p&gt;
&lt;h2 id=&quot;0-视频介绍&quot;&gt;&lt;a href=&quot;#0-视频介绍&quot; class=&quot;headerlink&quot; title=&quot;0. 视频介绍&quot;&gt;&lt;/a&gt;0. 视频介绍&lt;/</summary>
      
    
    
    
    <category term="Java学习" scheme="https://github.com/253715/253715.github.io.git/categories/Java%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="springboot" scheme="https://github.com/253715/253715.github.io.git/tags/springboot/"/>
    
    <category term="房屋出租管理系统" scheme="https://github.com/253715/253715.github.io.git/tags/%E6%88%BF%E5%B1%8B%E5%87%BA%E7%A7%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>spingboot</title>
    <link href="https://github.com/253715/253715.github.io.git/2022/04/30/spingboot/"/>
    <id>https://github.com/253715/253715.github.io.git/2022/04/30/spingboot/</id>
    <published>2022-04-30T06:32:41.000Z</published>
    <updated>2022-04-30T06:32:42.006Z</updated>
    
    
    
    
    
  </entry>
  
</feed>
